# модуль: dtmf_detect
# автор:  lastuniverse
# за основу взят Си код Mr. Blue:
#   http://www.phrack.org/issues.html?issue=50&id=13
# данный модуль содержит реализацию алгоритма Гёрцеля 
#   http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%93%D1%91%D1%80%D1%86%D0%B5%D0%BB%D1%8F
#   http://www.dsplib.ru/content/goertzel/goertzel.html

use v5.16;              # использовать версию Perl не ниже указанной
use strict;             # включить дополнительные проверки
use warnings;           # и расширенную диагностику
use diagnostics;        # выводить подробную диагностику ошибок
#use utf8;
#use locale;

package dtmf_decoder;   # указываем новое пространство имен

require Exporter;               # загрузить стандартный модуль Exporter
our @ISA = qw(Exporter);        # неизвестные имена искать в нем


our @EXPORT = qw(dtmf_sample dtmf_clear);   # имена, экспортируемые по умолчанию
our @EXPORT_OK = qw(_recalc );              # имена, экспортируемые по запросу

# в этом хэш массиве будем хранить все наши настройки и данные
my %o = (
  # хэш массив в котором будут храниться расчитанные коэфициенты
  # необходимые для работы алгоритма Гёрцеля
  f => {
    '697' => { K => 0, C => 0 },
    '770' => { K => 0, C => 0 },
    '852' => { K => 0, C => 0 },
    '941' => { K => 0, C => 0 },
    '1209' => { K => 0, C => 0 },
    '1336' => { K => 0, C => 0 },
    '1477' => { K => 0, C => 0 },
    '1633' => { K => 0, C => 0 },
  },
  # список частот строк и столбцов таблицы dtmf сигналов
  #          1209 Гц   1336 Гц   1477 Гц   1633 Гц
  # 697 Гц   1         2         3         A 
  # 770 Гц   4         5         6         B
  # 852 Гц   7         8         9         C
  # 941 Гц   *         0         #         D   
  rf => [ '697', '770', '852', '941' ],
  cf => [ '1209', '1336', '1477', '1633' ],
  # Вспомогательный хэш массив для определения номера dtmf сигнала
  dtmf => {
    '697' => { '1209' => 1, '1336' => 2, '1477' => 3, '1633' => 4 },
    '770' => { '1209' => 5, '1336' => 6, '1477' => 7, '1633' => 8  },
    '852' => { '1209' => 9, '1336' => 10, '1477' => 11, '1633' => 12  },
    '941' => { '1209' => 13, '1336' => 14, '1477' => 15, '1633' => 16  },
  },
  # Список наименований dtmf сигналов (входным параметром является 
  # значение из вспомогательного массивa dtmf)
  # выходным - наименование нажатой кгнопки
  info => ['NONE', '1', '2', '3', 'A', '4', '5', '6', 'B', '7', '8', '9', 'C', '*', '0', '#', 'D'],
  # далее идут параметры используемые для работы алгоритма
  tones => 0,   # расчитывается. ссодержит количество обрабатываемых частот
  rate => 8000, # частота оцифровки обрабатываемого сигнала
  len => 100,   # количество оцифровок обрабатываемых за раз
                # значение выбранно из расчета обработать за раз пакет из 320 байт
                # считанных из аудиопорта модема (2 байта на 1 оцифровку) 
                # (уменьшил до 100 для увеличения скорости обработки)
  range => 0.15,      # используется для приведения значений максимальной мощности
  thresh => 99999999, # используется для отсекания сигналов с мощностью менше указанной
  mincount => 4,      # минимальное количество пакетов в которых фиксируется нажатие кнопки
                      # для того чтобы алгоритм считал кнопку нажатой
                      # range, thresh и mincount подбирались опытным путем и тестировались
                      # нескольких десятков звуковых файлов содержащих dtmf сигналы и посторонние
                      # шумовые эффекты.

  debug => 0,     # включает вывод отладочной информации 

  # хэш массив содержащий временные данные работы алгоритма
  t => {
    mincount => 0,
    sample => [],
    power =>  {},
    maxpower => 0,
    thresh => 0,
    on    =>  {},
    last_dtmf => ''
  }
);

# данная функция производит предварительный расчет коэффициентов необходимых для работы алгоритма
sub _recalc {
  $o{tones} = scalar keys %{$o{f}};
  for my $f (sort { $a <=> $b } keys %{$o{f}}) {
    $o{f}{$f}{K} = $o{len} * $f / $o{rate};
    $o{f}{$f}{C} = 2.0 * cos( 2.0 * 3.14159265 * $o{f}{$f}{K} / $o{len} );
    print "COEFF: [$f] \t[$o{f}{$f}{K}] \t[$o{f}{$f}{C}]\n" if $o{debug};
  }
}

# данная функция производит предварительный расчет мощностей гармоник(указанных частот)
sub _calc_power {
  my $freq_list = shift;
  my @fk = @{$freq_list};
  my %ff = %{$o{f}};
  my %fp = %{$o{t}{power}};

  my %u0 = ();
  my %u1 = ();
  my $t  = 0.0;
  my $in = 0.0;
  my $i  = 0;

  for my $f (@fk) {
    $u0{$f} = 0.0;
    $u1{$f} = 0.0;
  }

  while ($i<$o{len}) {   # feedback
    $in = $o{t}{sample}[$i] || 0; # >> 7;
    for my $f (@fk) {
      $t = $u0{$f};
      $u0{$f} = $in + $ff{$f}{C} * $u0{$f} - $u1{$f};
      $u1{$f} = $t;
    }
    $i++;
  }

  print "MAXPOWER: [" if $o{debug} > 1;
  for my $f (@fk) {
    $o{t}{power}{$f} = $u0{$f} * $u0{$f} + $u1{$f} * $u1{$f} - $ff{$f}{C} * $u0{$f} * $u1{$f}; 
    $o{t}{maxpower} = $o{t}{power}{$f} if $o{t}{power}{$f} > $o{t}{maxpower};
    print "$o{t}{maxpower}, " if $o{debug} > 1;
  }
  print "]\n" if $o{debug} > 1;
}

# данная функция отсекает пакеты с мощьностью сигнала ниже $o{t}{maxpower}
# расчитывает проходной уровень мощности для частот
# и фиксирует частоты уровень мощности которых выше проходного в массиве $o{t}{on}{$f}
sub _midle_calc {
  my $freq_list = shift;
  my @fl = @{$freq_list};
  _calc_power($freq_list);

  return 0 if $o{t}{maxpower} < $o{thresh};
  $o{t}{thresh} = $o{range}  * $o{t}{maxpower};
  
  my $on_count = 0;
  for my $f (@fl) {
    if ($o{t}{power}{$f} > $o{t}{thresh}) {
      $o{t}{on}{$f} = 1;
      $on_count++;
    } else {
      $o{t}{on}{$f} = 0;
    }
    
  }
  return $on_count;
}

# данная функция производит проверку наличия 2-х частот в обработанном пакете
# 1-й частоты из группы частот означающих номер строки из таблицы dtmf
# и 1-й частоты из группы частот означающих номер колонки из таблицы dtmf
# если проверка пройдена - возвращает значение из массива dtmf (номер)
sub _decode {
  my $row_count = _midle_calc($o{rf});
  return 0 unless $row_count;

  my $col_count += _midle_calc($o{cf});
  return 0 unless $col_count;
  return 0 unless $row_count == 1 && $col_count == 1;
  for my $dtmf (@{$o{rf}}) {
    if ($o{t}{on}{$dtmf}) {
      for my $f (@{$o{cf}}) {
        return $o{dtmf}{$dtmf}{$f} if $o{t}{on}{$f};
      }
    }
  }
  #return 0 if $on_count == 0;
  return 0; 
}

# данная функция производит финальную проверку наличия dtmf сигнала
# основываясь на его длительности (mincount) отсекая случайные срабатывания
# и возвращает название нажатой кнопки из массива info
sub _analise {
  my $x = _decode();
  _sample_clear();
  #return $x;

  if ($x && $x == $o{t}{last_dtmf}){
    $o{t}{mincount}++;
  } else {
    if ( $o{t}{last_dtmf} && $x != $o{t}{last_dtmf} ) {
      if ($o{t}{mincount} >= $o{mincount}){
        my $r = $o{t}{last_dtmf};
        $o{t}{last_dtmf} = $x;
        return $r;
      }
    }
    $o{t}{mincount} = 0;
  }
  
  $o{t}{last_dtmf} = $x;
  return 0;
}

# служебная функция для отчистки результатов промежуточных расчетов
# вызывается после расчетов мощьностей для каждого пакета
sub _sample_clear {
  $o{t}{sample} = [];
  $o{t}{power} = {};
  $o{t}{maxpower} = 0;
  $o{t}{on} = {};
  $o{t}{thresh} = 0;
}

# функция для отчистки результатов промежуточных расчетов
# вызывается по завершении голосового вызова
sub dtmf_clear {
  _sample_clear();
  $o{t}{mincount} = 0;
  $o{t}{last_dtmf} = {};
}

# функция принимающая на обработку пакет аудиоданных
# и возвращающая название нажатой кнопки в случае
# обнаружения dtmf сигнала
sub dtmf_sample {
  my $_ = shift;
  my @a = unpack("s$o{len}");
  $o{t}{sample} = \@a;
  my $x = _analise(); 
  print "DTMF: [".$o{info}[$x]."]\n" if $x; #&& $o{debug};
  return $o{info}[$x] if $x;

}

# производим расчет коэффициентов по умолчанию при подключении модуля
_recalc();

1;
